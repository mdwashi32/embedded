/*
 * stm32f407xx_rcc_driver.c
 *
 *  Created on: Aug 6, 2025
 *      Author: mauricewashington
 */

#ifndef SRC_STM32F407XX_RCC_DRIVER_C_
#define SRC_STM32F407XX_RCC_DRIVER_C_

#include "stm32f407xx_rcc_driver.h"

uint16_t AHB1_PreScaler[8] = {2,4,8,16,64,128,256,512};
uint16_t APB1_PreScaler[8] = {2,4,8,16};
uint16_t APB2_PreScaler[8] = {2,4,8,16};

uint32_t RCC_GetPCLK1Value(void)
{
	uint32_t pclk1,SystemClk;

	uint8_t clksrc,temp,ahb1p,apb1p;

	clksrc = ((RCC->CFGR >> 2) & 0x3); // only want bit positions 0 and 1

	if (clksrc == 0)
	{
		SystemClk = 16000000;
	}
	else if (clksrc == 1)
	{
		SystemClk = 8000000;
	}
	else if (clksrc == 2)
	{
		SystemClk = RCC_GetPLLOutputClock(); // not implemented
	}

	//ahb1 pre-scaler
	temp = ((RCC->CFGR >> 4) & 0xF);

	if (temp < 8)
	{
		ahb1p = 1;
	}
	else
	{
		ahb1p = AHB1_PreScaler[temp - 8]; // if ahb1 prescaler greater than 8, fetch first value of array
	}

	//apb1 pre-scaler
	temp = ((RCC->CFGR >> 10) & 0x7);

	if (temp < 4)
	{
		apb1p = 1;
	}
	else
	{
		apb1p = APB1_PreScaler[temp - 4]; // if apb1 prescaler greater than 4, fetch first value of array
	}

	pclk1 = (SystemClk / ahb1p) / apb1p;

	return pclk1;
}

uint32_t RCC_GetPCLK2Value(void)
{
	uint32_t pclk2,SystemClk;

	uint8_t clksrc,temp,ahb1p,apb2p;

	clksrc = ((RCC->CFGR >> 2) & 0x3); // only want bit positions 0 and 1

	if (clksrc == 0)
	{
		SystemClk = 16000000;
	}
	else if (clksrc == 1)
	{
		SystemClk = 8000000;
	}
	else if (clksrc == 2)
	{
		SystemClk = RCC_GetPLLOutputClock(); // not implemented
	}

	//ahb1 pre-scaler
	temp = ((RCC->CFGR >> 4) & 0xF);

	if (temp < 8)
	{
		ahb1p = 1;
	}
	else
	{
		ahb1p = AHB1_PreScaler[temp - 8]; // if ahb1 prescaler greater than 8, fetch first value of array
	}

	//apb2 pre-scaler
	temp = ((RCC->CFGR >> 13) & 0x7);

	if (temp < 4)
	{
		apb2p = 1;
	}
	else
	{
		apb2p = APB2_PreScaler[temp - 4]; // if apb2 prescaler greater than 4, fetch first value of array
	}

	pclk2 = (SystemClk / ahb1p) / apb2p;

	return pclk2;
}

#endif /* SRC_STM32F407XX_RCC_DRIVER_C_ */
