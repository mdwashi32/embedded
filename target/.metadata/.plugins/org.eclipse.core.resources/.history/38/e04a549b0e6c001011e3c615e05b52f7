/*
 * stm32f407xx_i2c_driver.c
 *
 *  Created on: Jul 22, 2025
 *      Author: mauricewashington
 */

#include "stm32f407xx_i2c_driver.h"

uint16_t AHB1_PreScaler[8] = {2,4,8,16,64,128,256,512};
uint16_t APB1_PreScaler[8] = {2,4,8,16};

static void I2C_GenerateStartCondition(I2C_RegDef_t *pI2Cx);
static void I2C_ExecuteAddressPhase(I2C_RegDef_t *pI2Cx, uint8_t SlaveAddr);
static void I2C_ClearADDRFlag(I2C_RegDef_t *pI2Cx);
static void I2C_GenerateStopCondition(I2C_RegDef_t *pI2Cx);


static void I2C_GenerateStartCondition(I2C_RegDef_t *pI2Cx)
{
	pI2Cx->CR1 |= ( 1 << I2C_CR1_START);
}

static void I2C_ExecuteAddressPhase(I2C_RegDef_t *pI2Cx, uint8_t SlaveAddr)
{
	SlaveAddr = SlaveAddr << 1; //makes space for R/WR bit
	SlaveAddr &= ~(1 << 0); //clear 0th bit so SlaveAddr is Slave address + r/nw bit (write = 0)
	pI2Cx->DR = SlaveAddr;
}

static void I2C_ClearADDRFlag(I2C_RegDef_t *pI2Cx) // read SR1 followed by SR2
{
	uint32_t dummyRead = pI2Cx->SR1;
	dummyRead = pI2Cx->SR2;
	(void)dummyRead;
}

static void I2C_GenerateStopCondition(I2C_RegDef_t *pI2Cx)
{
	pI2Cx->CR1 |= ( 1 << I2C_CR1_STOP);
}
/*
 * Peripheral Clock Setup
 */
/*************************************************************************************************************
 * FUNCTION DETAILS
 * 	@function				-	I2C_PeriClockControl
 *
 * 	@brief					-	This function enables or disables peripheral clock for given I2C peripheral
 *
 * 	@param[in]				-	Base address of I2C peripheral
 * 	@param[in]				-	ENABLE OR DISABLE (macro)
 * 	@param[in]				-
 *
 * 	@return					-	none
 *
 * 	@Note					-	none
 *************************************************************************************************************/
void I2C_PeriClockControl(I2C_RegDef_t *pI2Cx, uint8_t EnorDi)
{
	if(EnorDi == ENABLE)
	{
		if(pI2Cx == I2C1)
		{
			I2C1_PCLK_EN();
		}
		else if(pI2Cx == I2C2)
		{
			I2C2_PCLK_EN();
		}
		else if(pI2Cx == I2C3)
		{
			I2C3_PCLK_EN();
		}
	}

	else
	{
		if(pI2Cx == I2C1)
		{
			I2C1_PCLK_DI();
		}
		else if(pI2Cx == I2C2)
		{
			I2C2_PCLK_DI();
		}
		else if(pI2Cx == I2C3)
		{
			I2C3_PCLK_DI();
		}
	}
}

/*
 * Init and De-init (reset)
 */
uint32_t RCC_GetPLLOutputClock(void) /**** Not implemented ***/
{

	return 0;
}

uint16_t AHB_PreScaler[8] = {2,4,8,16,64,128,256,512};

uint32_t RCC_GetPCLK11Value(void)
{
	uint32_t pclk1,SystemClk;

	uint8_t clksrc,temp,ahb1p,apb1p;

	clksrc = ((RCC->CFGR >> 2) & 0x3); // only want bit positions 0 and 1

	if (clksrc == 0)
	{
		SystemClk = 16000000;
	}
	else if (clksrc == 1)
	{
		SystemClk = 8000000;
	}
	else if (clksrc == 2)
	{
		SystemClk = RCC_GetPLLOutputClock(); // not implemented
	}

	//ahb1 pre-scaler
	temp = ((RCC->CFGR >> 4) & 0xF);

	if (temp < 8)
	{
		ahb1p = 1;
	}
	else
	{
		ahb1p = AHB1_PreScaler[temp - 8]; // if ahb1 prescaler greater than 8, fetch first value of array
	}

	//apb1 pre-scaler
	temp = ((RCC->CFGR >> 10) & 0x7);

	if (temp < 4)
	{
		apb1p = 1;
	}
	else
	{
		apb1p = APB1_PreScaler[temp - 4]; // if apb1 prescaler greater than 4, fetch first value of array
	}

	pclk1 = (SystemClk / ahb1p) / apb1p;

	return pclk1;
}

/*************************************************************************************************************
 * FUNCTION DETAILS
 * 	@function				-	I2C_Init
 *
 * 	@brief					-	This function resets the I2C peripheral
 *
 * 	@param[in]				-	Base address of I2C peripheral
 * 	@param[in]				-
 * 	@param[in]				-
 *
 * 	@return					-	none
 *
 * 	@Note					-	none
 *************************************************************************************************************/
void I2C_Init(I2C_Handle_t *pI2CHandle)
{
	uint32_t tempreg = 0;

	// ACK control bit
	tempreg |= pI2CHandle->I2C_Config.I2C_ACKControl << 10;
	pI2CHandle->pI2Cx->CR1 = tempreg;

	// FREQ Configuration
	tempreg = 0;
	tempreg |= RCC_GetPCLK1Value() / 1000000U;
	pI2CHandle->pI2Cx->CR2 = (tempreg & 0x3F); // mask all except first 5 bits

	// Device Own Address Configuration (OAR1)
	tempreg = 0;
	tempreg |= pI2CHandle->I2C_Config.I2C_DeviceAddress << 1;
	tempreg |= (1 << 14);
	pI2CHandle->pI2Cx->OAR1 = tempreg;

	// CCR Configuration
	tempreg = 0;
	uint16_t ccr_value = 0;

	if(pI2CHandle->I2C_Config.I2C_SCLSpeed <= I2C_SCL_SPEED_SM)
	{
		// standard mode
		ccr_value =(RCC_GetPCLK1Value() / (2 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
		tempreg |= (ccr_value & 0xFFF);
	}
	else
	{
		// fast mode
		tempreg |= (1 << 15); //set fast mode
		tempreg |= (pI2CHandle->I2C_Config.I2C_FMDutyCycle << 14);
		if(pI2CHandle->I2C_Config.I2C_FMDutyCycle == I2C_FM_DUTY_2)
		{
			ccr_value = (RCC_GetPCLK1Value() / (3 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
		}
		else
		{
			ccr_value = (RCC_GetPCLK1Value() / (25 * pI2CHandle->I2C_Config.I2C_SCLSpeed));
		}
		tempreg |= (ccr_value & 0xFFF);
	}
	pI2CHandle->pI2Cx->CCR = tempreg;

	//TRISE Configuration
	tempreg = 0;

	if(pI2CHandle->I2C_Config.I2C_SCLSpeed <= I2C_SCL_SPEED_SM)
	{
		// standard mode
		tempreg = (RCC_GetPCLK1Value() / 1000000U) + 1;
	}
	else
	{
		// fast mode
		tempreg = ((RCC_GetPCLK1Value() * 300U) / 1000000000U) + 1;
	}

	pI2CHandle->pI2Cx->TRISE = (tempreg & 0x3F);
}

/*************************************************************************************************************
 * FUNCTION DETAILS
 * 	@function				-	I2C_DeInit
 *
 * 	@brief					-	This function resets the given I2C peripheral
 *
 * 	@param[in]				-	Base address of I2C peripheral
 * 	@param[in]				-
 * 	@param[in]				-
 *
 * 	@return					-	none
 *
 * 	@Note					-	none
 *************************************************************************************************************/

void I2C_DeInit(I2C_RegDef_t *pI2Cx)
{
	if(pI2Cx == I2C1)
	{
		I2C1_REG_RESET();
	}
	else if(pI2Cx == I2C2)
	{
		I2C2_REG_RESET();
	}
	else if(pI2Cx == I2C3)
	{
		I2C3_REG_RESET();
	}
}

/*
 * Data Send and Receive
 */

uint8_t I2C_GetFlagStatus(I2C_RegDef_t *pI2Cx, uint32_t FlagName)
{
	if(pI2Cx->SR1 & FlagName)
	{
		return FLAG_SET;
	}
	return FLAG_RESET;
}

/*************************************************************************************************************
 * FUNCTION DETAILS
 * 	@function				-	I2C_MasterSendData
 *
 * 	@brief					-	This function sends data from Master to Slave
 *
 * 	@param[in]				-	Base address of I2C peripheral
 * 	@param[in]				-	Address of Transfer Buffer
 * 	@param[in]				-	Length of transmitted data (bytes)
 * 	@param[in]				-	Slave Address
 *
 * 	@return					-	none
 *
 * 	@Note					-	none
 *************************************************************************************************************/
void I2C_MasterSendData(I2C_Handle_t *pI2CHandle, uint8_t *pTxBuffer, uint32_t Len, uint8_t SlaveAddr)
{
	//1. Generate START Condition

	I2C_GenerateStartCondition(pI2CHandle->pI2Cx);

	//2. Confirm that start generation is completed by checking the SB flag in SR1
	//	 Note: Until SB is cleared SCL will be stretched (pulled LOW)

	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_SB_FLAG));

	//3. Send the address of the slave with r/nw bit set to w(0) (total 8 bits)

	I2C_ExecuteAddressPhase(pI2CHandle->pI2Cx, SlaveAddr);

	//4. Confirm that the address phase is completed by checking the ADDR flag in the SR1

	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_ADDR_FLAG));

	//5. Clear the ADDR flag according to its software sequence
	//	 Note: Until ADDR is cleared SCL will be stretched (pulled LOW)

	I2C_ClearADDRFlag(pI2CHandle->pI2Cx);

	//6. Send the data until Len is 0 (Tx empty)

	while(Len > 0)
	{
		while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_TXE_FLAG)); // Wait for TXE to be set
		pI2CHandle->pI2Cx->DR = *pTxBuffer;
		pTxBuffer++;
		Len--;
	}

	//7. When Len becomes zero wait for TXE=1 and BTF=1 before generating STOP condition
	//	 Note: TXE=1 , BTF=1 , means that both SR and DR are empty and next transmission should begin
	//	 When BTF=1 , SCL will be stretched (pulled LOW)

	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_TXE_FLAG)); // Wait for TXE to be set

	while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_BTF_FLAG)); // Wait for TXE to be set


	//8. Generate STOP Condition and master need not wait for the completion of STOP condition
	//	 Note: Generating STOP automatically clears the BTF

	I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
}




/*
 * IRQ Configuration and ISR Handling
 */

/*************************************************************************************************************
 * FUNCTION DETAILS
 * 	@function				-	I2C_IRQInterruptConfig
 *
 * 	@brief					-	This function enables/disables interrupts for I2C
 *
 * 	@param[in]				-	Interrupt Request Number
 * 	@param[in]				-	ENABLE or DISABLE (macro)
 *
 * 	@return					-	none
 *
 * 	@Note					-	none
 *************************************************************************************************************/

void I2C_IRQInterruptConfig(uint8_t IRQNumber, uint8_t EnorDi)
{
	if (EnorDi == ENABLE)
		{
			if(IRQNumber <= 31)
			{
				//program ISER0
				*NVIC_ISER0 |= (1 << IRQNumber);
			}
			else if (IRQNumber > 32 && IRQNumber < 64)
			{
				//program ISER1
				*NVIC_ISER1 |= (1 << IRQNumber % 32);
			}
			else if (IRQNumber > 64 && IRQNumber < 96)
			{
				//ISER2
				*NVIC_ISER2 |= (1 << IRQNumber % 64);
			}
		}
		else
		{
			if(IRQNumber <= 31)
			{
				//ICER0
				*NVIC_ICER0 |= (1 << IRQNumber);
			}
			else if (IRQNumber > 32 && IRQNumber < 64)
			{
				//ICER1
				*NVIC_ICER1 |= (1 << IRQNumber % 32);
			}
			else if (IRQNumber > 64 && IRQNumber < 96)
			{
				//ICER2
				*NVIC_ICER2 |= (1 << IRQNumber % 64);
			}
		}
}

/*************************************************************************************************************
 * FUNCTION DETAILS
 * 	@function				-	I2C_IRQPriorityConfig
 *
 * 	@brief					-	This function sets interrupt priority
 *
 * 	@param[in]				-	Interrupt Request Number
 * 	@param[in]				-	Interrupt Priority
 * 	@param[in]				-
 *
 * 	@return					-	none
 *
 * 	@Note					-	none
 *************************************************************************************************************/

void I2C_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority)
{
	//1. first determine IPR register
	uint8_t iprx = IRQNumber / 4;
	uint8_t iprx_section = IRQNumber % 4 ;

	//2. set priority
	uint8_t shift_amount = (8 * iprx_section) + (8 - NO_PR_BITS_IMPLEMENTED);
	*(NVIC_PR_BASE_ADDR + iprx) |= (IRQPriority << shift_amount); // +iprx because pointer arithmetic leads to +4 address bytes
}

/*************************************************************************************************************
 * FUNCTION DETAILS
 * 	@function				-	I2C_PeripheralControl
 *
 * 	@brief					-	This function enables or disables I2C peripheral
 *
 * 	@param[in]				-	Base address of I2C peripheral
 * 	@param[in]				-	Enable or Disable
 * 	@param[in]				-
 *
 * 	@return					-	none
 *
 * 	@Note					-	none
 *************************************************************************************************************/

void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx, uint8_t EnOrDi)
{
	if(EnOrDi == ENABLE)
	{
		pI2Cx->CR1 |= (1 << I2C_CR1_PE);
	}
	else
	{
		pI2Cx->CR1 &= ~(1 << I2C_CR1_PE);
	}
}



